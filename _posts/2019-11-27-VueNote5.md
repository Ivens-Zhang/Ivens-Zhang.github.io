---
layout: post
title: "Vue.js学习笔记(五)"
subtitle: ''
author: "Ivens"
header-mask: 0.1
header-img: "img/in-post/2019-11-18/th2.jpg"
hidden: true
catalog: true
tags:
  - Vue.js
---
- [前言](#%e5%89%8d%e8%a8%80)
- [正文](#%e6%ad%a3%e6%96%87)
  - [组件中使用的细节点](#%e7%bb%84%e4%bb%b6%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9a%84%e7%bb%86%e8%8a%82%e7%82%b9)
    - [使用`is`解决H5的小bug](#%e4%bd%bf%e7%94%a8is%e8%a7%a3%e5%86%b3h5%e7%9a%84%e5%b0%8fbug)
    - [组件中的`data`必须以函数形式定义](#%e7%bb%84%e4%bb%b6%e4%b8%ad%e7%9a%84data%e5%bf%85%e9%a1%bb%e4%bb%a5%e5%87%bd%e6%95%b0%e5%bd%a2%e5%bc%8f%e5%ae%9a%e4%b9%89)
    - [`ref`的使用](#ref%e7%9a%84%e4%bd%bf%e7%94%a8)
  - [父子组件的数据传递](#%e7%88%b6%e5%ad%90%e7%bb%84%e4%bb%b6%e7%9a%84%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%92)
    - [单向数据流](#%e5%8d%95%e5%90%91%e6%95%b0%e6%8d%ae%e6%b5%81)
    - [vm.$emit的使用](#vmemit%e7%9a%84%e4%bd%bf%e7%94%a8)
  - [组件参数校验](#%e7%bb%84%e4%bb%b6%e5%8f%82%e6%95%b0%e6%a0%a1%e9%aa%8c)
  - [非props特性与为组件绑定原生事件](#%e9%9d%9eprops%e7%89%b9%e6%80%a7%e4%b8%8e%e4%b8%ba%e7%bb%84%e4%bb%b6%e7%bb%91%e5%ae%9a%e5%8e%9f%e7%94%9f%e4%ba%8b%e4%bb%b6)
    - [非props特性](#%e9%9d%9eprops%e7%89%b9%e6%80%a7)
    - [为组件绑定原生事件](#%e4%b8%ba%e7%bb%84%e4%bb%b6%e7%bb%91%e5%ae%9a%e5%8e%9f%e7%94%9f%e4%ba%8b%e4%bb%b6)
  - [非父子组件间传值(Bus/总线/发布订阅模式/观察者模式)](#%e9%9d%9e%e7%88%b6%e5%ad%90%e7%bb%84%e4%bb%b6%e9%97%b4%e4%bc%a0%e5%80%bcbus%e6%80%bb%e7%ba%bf%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f)

## 前言

在这几天学习的过程中发现一个问题,有的时候老师在视频中出现`Vue warn`的地方我都没有,而且可以正常显示.

一开始我以为是版本的问题,可能我现在用的是最新版Vue,一些问题都已经解决了.但是直到今天(2019年11月27日)我才发现原因.

在`BootCDN`中引用Vue时,我选择了min版本的,这造成很多warn不会被报出来.

以后开发的时候还是使用common版或者未压缩的更好.

## 正文

### 组件中使用的细节点

#### 使用`is`解决H5的小bug
[《Vue官方文档---is》](https://cn.vuejs.org/v2/api/#is)

先看一段代码:
```html
<div id="root">
  <table>
    <tbody>
      <row></row>
      <row></row>
      <row></row>
    </tbody>
  </table>
</div>
<script>
  Vue.component('row',{
    template: '<tr><td>XXX</td></tr>'
  })
  var vm = new Vue({
    el: '#root'
  })
</script>
```

当我们这样使用组件时会出现以下问题:
![](../../../../img/in-post/2019-11-27/a.png)
这时,`row`组件中添加的`tr`全部都在`table`外面,**原因是在H5的规范中,要求我们在tbody中只能放tr标签,当浏览器解析到的是row标签时,就会出现这样的问题.**

解决这个问题可以使用Vue提供的`is`属性.

```html
<div id="root">
  <table>
    <tbody>
      <tr is="row"></tr>
      <tr is="row"></tr>
      <tr is="row"></tr>
    </tbody>
  </table>
</div>
```

#### 组件中的`data`必须以函数形式定义
组件的 `data` 选项必须是一个函数，**因此每个实例可以维护一份被返回对象的独立的拷贝**.

如果 Vue 没有这条规则，改变一个组件中的`data`会影响到其它所有实例.


#### `ref`的使用

[《Vue官方文档---ref》](https://cn.vuejs.org/v2/api/#ref)

`ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上。

**如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例.**

### 父子组件的数据传递

#### 单向数据流

[《官方文档---单向数据流》](https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81)

父级 prop 的更新会向下流动到子组件中，但是反过来则不行。**这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。**

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着**你不应该在一个子组件内部改变 prop**。

如果你这样做了，Vue 会在浏览器的控制台中发出警告。

解决方法:

在子组件中加入`data`,在其中定义一个空值接收父组件传入的值.后面对这个新定义的值进行改动即可.
#### vm.$emit的使用

[《父子组件间通信实例讲解(props、$ref、$emit)》](https://www.jb51.net/article/140581.htm)

```js
vm.$emit( event, arg )
```

`$emit` 绑定一个自定义事件event，当这个这个语句被执行到的时候，就会将参数arg传递给父组件，父组件通过`@event`监听并接收参数。

### 组件参数校验
<!-- {% raw %} -->
```js
var counter = {
  // props: ['content'],     这是最普通的使用方法

  props: {

    // content: String      这种写法可以规定传入值的类型

    content: {

      // 检测类型,可以像上面一样只符合一种类型,也可以用数组包括很多种类型
      type: [String,Number],

      // 规定是否必须传入一个对应的参数
      required: false,

      // 规定如果没传入对应值,则使用该默认值
      default: 'default value',

      // 校验器(validator)  value为传入的值,通过判断返回值来判断是否报出警告
      validator: function(value){
        return (value.length > 5)
      }
    }

  },
  template: '<div>{{content}}</div>'
}
```
<!-- {% endraw %}) -->



### 非props特性与为组件绑定原生事件
#### 非props特性

1. 无法在子组件中调用
2. 该属性会显示在DOM中

#### 为组件绑定原生事件
在事件后加`.native`即可,如:
```html
<child @clcik.native="handleClick()"></child>
```

### 非父子组件间传值(Bus/总线/发布订阅模式/观察者模式)
<!-- {% raw %} -->
```html
<body>
  <div id="root">
    <child content="I am A"></child>
    <child content="I am B"></child>
  </div>
  <script>
    Vue.prototype.bus = new Vue();

    Vue.component('child',{
      props:{
        content: String
      },
      data: function() {
        return {
          selfContent : this.content
        }
      },
      methods: {
        handleClick () {
          this.bus.$emit('change', this.selfContent);
        }
      },
      mounted() {
        var this_ = this;
        this.bus.$on('change',function (msg) {  
          // 注意:这里的alert函数会触发两次,因为两个父组件都被触发了change事件
          // alert(msg);
          this_.selfContent = msg
        });
      },
      template: '<div @click="handleClick()">{{selfContent}}</div>'
    })

    var vm = new Vue({
      el: '#root'
    })
  </script>
</body>
```
<!-- {% endraw %}) -->

先为Vue的原型添加一个`bus`的方法,然后当我们点击`div`时,会向`bus`提交一个当前`content`的参数,因为其他父组件也会被触发事件,所以数值一起发生改变.