---
layout: post
title: "简单理解POP、OOP、SOA、AOP的概念、适用与优缺点？"
subtitle: '编程思想就是一种解决现实问题的一种思考方式。'
author: "Ivens"
header-style: text
tags:
  - 编程
---


> 编程思想就是一种解决现实问题的一种思考方式，而每一种语言都是对现实问题描述进行抽象，从而让计算机去解决。

### 目前主流的四大的编程思想 :

 - **POP：面向过程编程(Process-oriented programming )**
 - **OOP：面向对象编程(Object Oriented Programming)**
 - **SOA：面向服务的架构(Service-Oriented Architecture)**
 - **AOP：面向切面编程(Aspect Oriented Programming)**

##  具体介绍
###  POP：
> “面向过程”(Procedure Oriented)是一种**以过程为中心**的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。 ——《面向过程》·百度百科

**举例：把大象装进冰箱的步骤**
<img src="https://img-blog.csdnimg.cn/2019080614012790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAwMjI3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**面向过程注重过程的, 当解决一个问题的时候，面向过程会把事情拆分成： 多个函数和数据, 然后按照一定的顺序执行这些方法（每个方法看作一个过程）。**

优点：

- 性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源


缺点：

- 难以维护、难以复用、难以拓展

### OOP:

> 面向对象（Object Oriented，OO）作为一种新型的程序设计方法，其是以对象模型为基础进行的抽象过程，并在应用过程中形成了描述自己的抽象概念定义，包括对象、类、封装、继承以及多态等。——《面向对象编程》·百度百科

面向对象编程是使用对象的编程范式——包含数据域、方法以及它们之间的交互来设计应用和程序。其程序设计方法包括数据抽象、封装、通信、模块化、多态和继承。简单来看,我们可以对面向对象编程作出如下几点理解：首先，它必须将数据抽象为模块结构；其次，必须存在某种方式来实现代码的多态执行；最后,它至少能部分压缩代码和函数。

面向对象的三个基本特征是：封装、继承、多态。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806141544538.gif)
####  封装：

> 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

####  继承：

> **继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。**

>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。
**继承的过程，就是从一般到特殊的过程。**
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
*在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。* 

>继承概念的实现方式有三类：**实现继承、接口继承和可视继承**。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

>在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。
**OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。**

####  多态:
>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。**

>实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”

>**那么，多态的作用是什么呢？**
>我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。


**举例：把大象装进冰箱的步骤**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806141309534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAwMjI3Mg==,size_16,color_FFFFFF,t_70)
**优点：**

==（1）易学好用。==
传统的程序设计技术是面向过程的设计方法，这种方法以算法为核心，把数据和过程作为相互独立的部分，数据代表问题空间中的客体，程序代码则用于处理这些数据。把数据和代码代为分离的实体，反映了计算机的观点，因为在计算机的内部数据和程序是分开存放的。但是，这样做的时候总存在使用错误的数据调用正确的程序模块，或使用正确的数据调用错误的程序模块的危险。使数据和操作保持一致，是程序员一个沉重负担，在多人分工合作开发一个大型软件系统的过程中，如果负责设计数据结构的人中途改变了某个数据的结构而又没有及时通知所有人员，则会发生许多不该发生的错误。面向对象的软件技术为开发者提供了随着对某个应用系统的认识逐步深入和具体化的过程，随着认识深入和具体化再逐步派生出更具体的派生类。这样的开发过程符合人们认识客观世界，解决复杂问题时逐步深化渐进过程。

==（2）稳定性好。==
传统的软件开发方法以算法为核心，开发过程基于功能分析和功能分解。用传统方法所建立起来的软件系统的结构紧密依赖于系统所要完成的功能，用传统的面向过程方法来实现模块化技术时，一个很大的障碍是无法实现同一模块的多次同时运行，例如，假设一个完成银行日常业务的系统，其中一个小模块专门用来实现队列的功能，包括一些与队列有关的基本操作，如插入一个事物、删除一个事物、检测队列是否已满等。由于队列是一种常用的数据结构，在系统中可能会有多处同时使用，如未划转业务队列，未确认业务队列等。这些队列虽然有相同的操作，遵循相同的规则，但却是相互独立的。这样的要求用面向对象过程方法实现的模块是无法满足的。相反，用面向对象技术中的类来实现模块，用类的实例化，对象块用队列类来实现，类中包含了队列的各种操作。以这个队列为模板可以产生多个队列对象。每个对象都有相同的方法。但却可以独立地同时运行，应用于系统的不同场合，从而方便地解决了这个面向过程开发中颇为棘手的问题。

==（3）可重用性。==
为了能带来可观的商业利益，必须在更广泛范围中运用重用机制，而不是仅仅在程序设计这个层次上进行重用。因此，在OOA、OOD直到OOP中都显示表示问题域语义，其意义是十分深远的。随着时间的推移，软件开发组织既可能重用它在某个问题域内的OOA结果，也可能重用相应的OOD和OOP结果。

==（4）维护性好。==
尽管人们反复强调保持文档与源程序一致的必要性，但是，在实际工作中很难做到交付两类不同的文档，并使它们保持彼此完全一致，特别是考虑到进度、预算、能力和人员等限制因素时，做到两类文档完全一致几乎是不可能的。因此，维护人员最终面对的往往只有源程序本身。

<br>
<br>

**缺点：**

==（1）运行效率较低。==
类的大量加载会牺牲系统性能，降低运行速度。虽然CPU速度在提高，内存容量在增加，但这一问题仍会随着系统规模变大而逐渐显示出来，变得越发严重。

==（2）类库庞大。==
由于类库都过于庞大，程序员对它们的掌握需要一段时间，从普及、推广的角度来看，类库应在保证其功能完备的基础上进行相应的缩减。

==（3）类库可靠性。==
越庞大的系统必会存在我们无法预知的问题隐患，程序员无法完全保证类库中的每个类在各种环境中百分之百的正确，当使用的类发生了问题，就会影响后续工作，程序员也有可能推翻原来的全部工作。
<br>

##  SOA:
**定义：**

> 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。**服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。**

>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。

>SOA将能够帮助软件工程师们站在一个新的高度理解企业级架构中的各种组件的开发、部署形式，它将帮助企业系统架构者以更迅速、更可靠、更具重用性架构整个业务系统。**较之以往，以SOA架构的系统能够更加从容地面对业务的急剧变化。**

>**Soa系统是一种企业通用性架构。**

&nbsp;

**适用场景与具体细节参考以下链接：**
[SOA（Service-Oriented Architecture）面向服务的分布式架构详解](https://blog.csdn.net/zl834205311/article/details/80333531)
[SOA面向服务架构](https://www.jdon.com/soa.html)
&nbsp;

**优点：**

==1. 简单化系统的开发==
由于soa具有组合性，可以利用现有的SOA资源，根据同样的开放标准，在不受平台限制的基础上，可以直接利用现有的资源进行组合，让后在按照自己的客户需求，进行进一步的开放。

==2. 面向企业商业流程==
SOA是基于服务的构造，所以开放的出发点，就是如何解决企业流程中出现的问题。

==3. 更好的适应性和扩展性==
由于soa的组件性，和优良的扩展性以及其组件性等待特征，SOA可以更具不同的需求，进行重新的组合和构造。

==4. 互用性==
==5. 对系统的升级，分布，和维护有个更多的优化==
==6. 简化了提供，寻找和使用服务的过程==
==7. 通过共同资源的利用，减少了开支==

<br>

**缺点：**
==1. 减低了系统的性能==
==2. 在向标准化过度的转换过程，增加了简介费用==
==3. 很多没有太多意义的文件型信息==
==4. 对商业流程的计划要求甚高==
<br>

##  AOP:
**定义：**

> 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。


>&nbsp;
 >**编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。**
><br>


 **适用场景与具体细节参考以下链接：**
 [一文读懂 AOP | 你想要的最全面 AOP 方法探讨](https://www.jianshu.com/p/0799aa19ada1)
 [Spring框架的核心功能之AOP技术](https://www.cnblogs.com/lxp503238/p/6837653.html)
<br>

#  感想
从最早C语言为代表的POP，到后来逐渐发展的OOP，直到如今SOA和AOP如此火热。这中间编程思想的变化代表了一代代IT工作者对于操作工具的不断思考，值得借鉴。
而且现在电脑的性能较之以往提升很大，这也是促成编程拆分越来越细的一个原因。